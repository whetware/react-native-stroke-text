///
/// HybridStrokeTextViewComponent.mm
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#import "HybridStrokeTextViewComponent.hpp"
#import <memory>
#import <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#import <React/RCTViewComponentView.h>
#import <React/RCTComponentViewFactory.h>
#import <React/UIView+ComponentViewProtocol.h>
#import <NitroModules/NitroDefines.hpp>
#import <UIKit/UIKit.h>

#import "HybridStrokeTextViewSpecSwift.hpp"
#import "NitroStrokeText-Swift-Cxx-Umbrella.hpp"

using namespace facebook;
using namespace margelo::nitro::stroketext;
using namespace margelo::nitro::stroketext::views;

/**
 * Represents the React Native View holder for the Nitro "StrokeTextView" HybridView.
 */
@interface HybridStrokeTextViewComponent: RCTViewComponentView
+ (BOOL)shouldBeRecycled;
@end

@implementation HybridStrokeTextViewComponent {
  std::shared_ptr<HybridStrokeTextViewSpecSwift> _hybridView;
}

+ (void) load {
  [super load];
  [RCTComponentViewFactory.currentComponentViewFactory registerComponentViewClass:[HybridStrokeTextViewComponent class]];
}

+ (react::ComponentDescriptorProvider) componentDescriptorProvider {
  return react::concreteComponentDescriptorProvider<HybridStrokeTextViewComponentDescriptor>();
}

- (instancetype) init {
  if (self = [super init]) {
    std::shared_ptr<HybridStrokeTextViewSpec> hybridView = NitroStrokeText::NitroStrokeTextAutolinking::createStrokeTextView();
    _hybridView = std::dynamic_pointer_cast<HybridStrokeTextViewSpecSwift>(hybridView);
    [self updateView];
  }
  return self;
}

- (void) updateView {
  // 1. Get Swift part
  NitroStrokeText::HybridStrokeTextViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Get UIView*
  void* viewUnsafe = swiftPart.getView();
  UIView* view = (__bridge_transfer UIView*) viewUnsafe;

  // 3. Update RCTViewComponentView's [contentView]
  [self setContentView:view];
}

- (void) updateProps:(const std::shared_ptr<const react::Props>&)props
            oldProps:(const std::shared_ptr<const react::Props>&)oldProps {
  // 1. Downcast props
  const auto& newViewPropsConst = *std::static_pointer_cast<HybridStrokeTextViewProps const>(props);
  auto& newViewProps = const_cast<HybridStrokeTextViewProps&>(newViewPropsConst);
  NitroStrokeText::HybridStrokeTextViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Update each prop individually
  swiftPart.beforeUpdate();

  // text: string
  if (newViewProps.text.isDirty) {
    swiftPart.setText(newViewProps.text.value);
    newViewProps.text.isDirty = false;
  }
  // color: optional
  if (newViewProps.color.isDirty) {
    swiftPart.setColor(newViewProps.color.value);
    newViewProps.color.isDirty = false;
  }
  // strokeColor: optional
  if (newViewProps.strokeColor.isDirty) {
    swiftPart.setStrokeColor(newViewProps.strokeColor.value);
    newViewProps.strokeColor.isDirty = false;
  }
  // strokeWidth: optional
  if (newViewProps.strokeWidth.isDirty) {
    swiftPart.setStrokeWidth(newViewProps.strokeWidth.value);
    newViewProps.strokeWidth.isDirty = false;
  }
  // fontSize: optional
  if (newViewProps.fontSize.isDirty) {
    swiftPart.setFontSize(newViewProps.fontSize.value);
    newViewProps.fontSize.isDirty = false;
  }
  // fontWeight: optional
  if (newViewProps.fontWeight.isDirty) {
    swiftPart.setFontWeight(newViewProps.fontWeight.value);
    newViewProps.fontWeight.isDirty = false;
  }
  // fontFamily: optional
  if (newViewProps.fontFamily.isDirty) {
    swiftPart.setFontFamily(newViewProps.fontFamily.value);
    newViewProps.fontFamily.isDirty = false;
  }
  // fontStyle: optional
  if (newViewProps.fontStyle.isDirty) {
    swiftPart.setFontStyle(newViewProps.fontStyle.value);
    newViewProps.fontStyle.isDirty = false;
  }
  // lineHeight: optional
  if (newViewProps.lineHeight.isDirty) {
    swiftPart.setLineHeight(newViewProps.lineHeight.value);
    newViewProps.lineHeight.isDirty = false;
  }
  // letterSpacing: optional
  if (newViewProps.letterSpacing.isDirty) {
    swiftPart.setLetterSpacing(newViewProps.letterSpacing.value);
    newViewProps.letterSpacing.isDirty = false;
  }
  // textAlign: optional
  if (newViewProps.textAlign.isDirty) {
    swiftPart.setTextAlign(newViewProps.textAlign.value);
    newViewProps.textAlign.isDirty = false;
  }
  // textDecorationLine: optional
  if (newViewProps.textDecorationLine.isDirty) {
    swiftPart.setTextDecorationLine(newViewProps.textDecorationLine.value);
    newViewProps.textDecorationLine.isDirty = false;
  }
  // textTransform: optional
  if (newViewProps.textTransform.isDirty) {
    swiftPart.setTextTransform(newViewProps.textTransform.value);
    newViewProps.textTransform.isDirty = false;
  }
  // opacity: optional
  if (newViewProps.opacity.isDirty) {
    swiftPart.setOpacity(newViewProps.opacity.value);
    newViewProps.opacity.isDirty = false;
  }
  // allowFontScaling: optional
  if (newViewProps.allowFontScaling.isDirty) {
    swiftPart.setAllowFontScaling(newViewProps.allowFontScaling.value);
    newViewProps.allowFontScaling.isDirty = false;
  }
  // maxFontSizeMultiplier: optional
  if (newViewProps.maxFontSizeMultiplier.isDirty) {
    swiftPart.setMaxFontSizeMultiplier(newViewProps.maxFontSizeMultiplier.value);
    newViewProps.maxFontSizeMultiplier.isDirty = false;
  }
  // includeFontPadding: optional
  if (newViewProps.includeFontPadding.isDirty) {
    swiftPart.setIncludeFontPadding(newViewProps.includeFontPadding.value);
    newViewProps.includeFontPadding.isDirty = false;
  }
  // numberOfLines: optional
  if (newViewProps.numberOfLines.isDirty) {
    swiftPart.setNumberOfLines(newViewProps.numberOfLines.value);
    newViewProps.numberOfLines.isDirty = false;
  }
  // ellipsizeMode: optional
  if (newViewProps.ellipsizeMode.isDirty) {
    swiftPart.setEllipsizeMode(newViewProps.ellipsizeMode.value);
    newViewProps.ellipsizeMode.isDirty = false;
  }
  // padding: optional
  if (newViewProps.padding.isDirty) {
    swiftPart.setPadding(newViewProps.padding.value);
    newViewProps.padding.isDirty = false;
  }
  // paddingVertical: optional
  if (newViewProps.paddingVertical.isDirty) {
    swiftPart.setPaddingVertical(newViewProps.paddingVertical.value);
    newViewProps.paddingVertical.isDirty = false;
  }
  // paddingHorizontal: optional
  if (newViewProps.paddingHorizontal.isDirty) {
    swiftPart.setPaddingHorizontal(newViewProps.paddingHorizontal.value);
    newViewProps.paddingHorizontal.isDirty = false;
  }
  // paddingTop: optional
  if (newViewProps.paddingTop.isDirty) {
    swiftPart.setPaddingTop(newViewProps.paddingTop.value);
    newViewProps.paddingTop.isDirty = false;
  }
  // paddingRight: optional
  if (newViewProps.paddingRight.isDirty) {
    swiftPart.setPaddingRight(newViewProps.paddingRight.value);
    newViewProps.paddingRight.isDirty = false;
  }
  // paddingBottom: optional
  if (newViewProps.paddingBottom.isDirty) {
    swiftPart.setPaddingBottom(newViewProps.paddingBottom.value);
    newViewProps.paddingBottom.isDirty = false;
  }
  // paddingLeft: optional
  if (newViewProps.paddingLeft.isDirty) {
    swiftPart.setPaddingLeft(newViewProps.paddingLeft.value);
    newViewProps.paddingLeft.isDirty = false;
  }

  swiftPart.afterUpdate();

  // 3. Update hybridRef if it changed
  if (newViewProps.hybridRef.isDirty) {
    // hybridRef changed - call it with new this
    const auto& maybeFunc = newViewProps.hybridRef.value;
    if (maybeFunc.has_value()) {
      maybeFunc.value()(_hybridView);
    }
    newViewProps.hybridRef.isDirty = false;
  }

  // 4. Continue in base class
  [super updateProps:props oldProps:oldProps];
}

+ (BOOL)shouldBeRecycled {
  return NitroStrokeText::NitroStrokeTextAutolinking::isStrokeTextViewRecyclable();
}

- (void)prepareForRecycle {
  [super prepareForRecycle];
  NitroStrokeText::HybridStrokeTextViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();
  swiftPart.maybePrepareForRecycle();
}

@end
